import java.text.SimpleDateFormat
import java.util.concurrent.TimeUnit
import com.thegoate.gradle.GoateGradleHelper
buildscript {
    repositories {
        mavenCentral()
        jcenter()
        mavenLocal()
    }
    dependencies {
        classpath 'com.sourcemuse.gradle.plugin:gradle-mongo-plugin:0.13.0'
        classpath "org.jfrog.buildinfo:build-info-extractor-gradle:4.0.0"
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.1'
        classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.4'
        classpath files('gradle/goate/gradle.jar')//this needs to be replaced when a version is finally published.
//        classpath 'goate:gradle7:1.0.201703131452'
    }
}

apply plugin: 'mongo'
mongo {
    port 27017
    storageLocation "mongo"
}
/**
apply plugin: "goate.version"
apply plugin: "goate.git"

versionInfo {
    versionProperties = "build.number.properties"
    versionIsTime = true;
    commitAfterIncrement = false;
}

git {
    properties = "git.settings"
}

task("release.version"){
    System.setProperty("incrementVersion", "number");
    dependsOn "incrementVersion"
    finalizedBy 'pushVersion'
}
/**/
//-Dorg.gradle.java.home=<path to jdk>
SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmm");
def maxJV = "8";//this should be updated when a new version of java is supported.
String javaVersion = "" + Integer.parseInt(project.hasProperty("javaVersion") ? (project.javaVersion.isEmpty() ? maxJV : project.javaVersion) : maxJV)
if (javaVersion.contains(".")) {
    javaVersion = javaVersion.substring(("" + javaVersion).indexOf(".") + 1);
}
//-Dorg.gradle.java.home=<path to jdk>
def vbase = '1.0'
def v = "${vbase}." + sdf.format(new Date());
def release = project.hasProperty("release") ? (project.release.equals("final") | project.release.equals("release") ? '' : project.release) : 'beta'

allprojects {
    repositories {
        mavenCentral()
        jcenter()
        mavenLocal()
    }
    apply plugin: 'idea'
    apply plugin: 'maven-publish'
    apply plugin: 'maven'
    apply plugin: 'com.jfrog.artifactory'
    apply plugin: 'jacoco'
    version = v + release;
    group = "goate"
    configurations {
        goatescala
    }
    dependencies{
        goatescala "org.scala-lang:scala-compiler:2.11.8"
        goatescala "org.scala-lang:scala-library:2.11.8"
        goatescala "org.scala-lang:scala-reflect:2.11.8"
        goatescala "org.scala-lang:scala-actors:2.11.8"
        goatescala "org.scala-lang:scala-xml:2.11.0-M4"
        goatescala "com.google.inject:guice:4.0"
    }
}

configurations.all {
    resolutionStrategy {
        cacheDynamicVersionsFor 5, TimeUnit.SECONDS
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.14' //version required
}

subprojects {
    configurations {
        annotations;
    }
    boolean oneOff = project.hasProperty("oneOff")
    def projectName = "${project.name}" + javaVersion
    projectName = projectName.replace(":", "").replace("module", "")
    apply plugin: 'java'
    apply plugin: 'groovy'
    apply plugin: 'jacoco'
    //apply plugin: 'application'

    project.ext.set("internalVersion", vbase);
    project.ext.set("javaVersion", Integer.parseInt(javaVersion));
    project.ext.set("maxJV", maxJV);
    project.ext.set("fullName", projectName);
    //mainClassName = project.hasProperty("main") ? project.main : ''
    idea {
        module {
            name = "${project.name}"
        }
    }
    sourceCompatibility = javaVersion
    targetCompatibility = javaVersion
    dependencies {
        testCompile 'ch.qos.logback:logback-classic:1.1.7'
        testCompile 'ch.qos.logback:logback-access:1.1.7'
        testCompile 'ch.qos.logback:logback-core:1.1.7'
        testCompile 'org.codehaus.janino:janino:2.7.8'
        compileOnly "org.atteo.classindex:classindex:3.3"
    }

    //def testRemote = project.hasProperty("remoteTest")?project.remoteTest.equals("true"):false;
    def testGroups = project.hasProperty("testGroups") ? (project.testGroups.equals("all") ? "unit,integration" : project.testGroups) : 'unit'
    def excludeGroup = project.hasProperty("excludeGroup") ? project.excludeGroup : ''
    def testSuite = project.hasProperty("testSuite") ? project.testSuite : ''
    def forks = project.hasProperty("forks") ? (project.forks.isEmpty() ? "1" : project.forks) : '1'
    def forksEvery = project.hasProperty("forksEvery") ? (project.forksEvery.isEmpty() ? "" : project.forksEvery) : ''
    def threads = project.hasProperty("threads") ? (project.threads.isEmpty() ? "1" : project.threads) : '1'

    test {
        exclude "**/GradleExcludeTrue1*"
        exclude "**/GradleExcludeTrue2*","**/GradleExcludeTrue3*"
        systemProperties System.getProperties();
        //setting checkTemplateLocation to false since they are not used.
        systemProperty "spring.freemarker.checkTemplateLocation", "false";
        systemProperty "spring.velocity.checkTemplateLocation", "false";
        systemProperty "user.dir", project.buildscript.sourceFile.parentFile.path
        useTestNG() {
            listeners << "org.testng.reporters.XMLReporter"
            if (testSuite.equals('')) {
                //System.out.println("\tgroup: " + testGroup)
                maxParallelForks = Long.parseLong("${forks}")
                if (!forksEvery.isEmpty()) {
                    forkEvery = Long.parseLong("${forksEvery}")
                }
                parallel = "tests"
                threadCount = Long.parseLong("${threads}")
                if (!testGroups.equals('')) {
                    includeGroups "${testGroups}"
                }
                if (!excludeGroup.equals('')) {
                    excludeGroups "${excludeGroup}"
                }
            } else {
                //println "executing test suite ${testSuite}"
                suites "${testSuite}"
                //useDefaultListeners true
            }
        }
    }
    jar.baseName = projectName

    sourceSets {
        test {
            resources { srcDirs "cucumbers" } //only needed for cucumbers
        }
    }
    jacoco {
        toolVersion = "0.7.6.201602180812"
    }
    configurations.all {
        resolutionStrategy.force 'xml-apis:xml-apis:1.4.01'
        exclude group: 'd-haven-managed-pool', module: 'd-haven-managed-pool'
        exclude group: 'event', module: 'event'
        exclude group: 'commons-math3', module: 'commons-math3'
        exclude group: 'commons-pool2', module: 'commons-pool2'
    }

    test.finalizedBy(project.tasks.jacocoTestReport)/**/
    install  {
        repositories.mavenInstaller {
            //System.out.println("installing: " + group + ":" + projectName + ":" + version)
            GoateGradleHelper.customPom(pom, configurations, project.javaVersion, oneOff)
            pom {
                project {
                    url 'http://www.thegoate.com'
                    // Set your license
                    licenses {
                        license {
                            name 'MIT'
                            url 'http://www.thegoate.com/licenses/LICENSE-MIT.txt'
                        }
                    }
                }
            }
            doLast{
                System.out.println("installed: " + project.group + ":" + projectName + ":" + version)
            }
        }
    }
    publishing {
        publications {
            goate(MavenPublication) {
                from components.java
                groupId "goate"
                artifactId projectName
                GoateGradleHelper.customPom(pom, configurations, project.javaVersion, true)
            }
        }
        model {
            tasks.generatePomFileForGoatePublication() {
                destination = file("$buildDir/${projectName}-${version}.pom")
            }
        }
    }

    artifactory {
        contextUrl = "${artifactory_url}"
        //The base Artifactory URL if not overridden by the publisher/resolver
        publish {
            repository {
                repoKey = 'vbs-maven-release'
                username = "${artifactory_user}"
                password = "${artifactory_password}"
                maven = true
            }
            defaults {
                publications('goate')
            }
        }
        resolve {
            repository {
                repoKey = 'libs-release'
                username = "${artifactory_user}"
                password = "${artifactory_password}"
                maven = true

            }
        }
    }
    idea {
        module {
            scopes.PROVIDED.plus += [configurations.annotations]
        }
    }
    task jarTest(type: Jar) {
        classifier = "tests"
        from sourceSets.test.output, sourceSets.main.output
    }

    task sourcesJar(type: Jar) {
        from sourceSets.main.allSource
        classifier = 'sources'
        baseName = "${projectName}"
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
        classifier = 'javadoc'
        from javadoc.destinationDir
        baseName = "${projectName}"
    }
    task groovydocJar(type: Jar, dependsOn: groovydoc) {
        classifier = 'groovydoc'
        from groovydoc.destinationDir
        baseName = "${projectName}"
    }

    task alldocsJar(type: Jar, dependsOn: [javadocJar,groovydocJar]){
        classifier = 'doc'
        from groovydocJar.archivePath,javadocJar.archivePath
        baseName = "${projectName}"
    }
    artifacts {
        archives alldocsJar
        archives sourcesJar
    }
}

jacoco {
    toolVersion = "0.7.6.201602180812"
}

// get class dirs for project dependencies
FileCollection getJacocoClassDirs() {
    Set srcDirs = subprojects.sourceSets.main.output
    return files(srcDirs)
}

FileCollection getJacocoExecFiles() {
    Set srcDirs = subprojects.jacocoTestReport.executionData
    Iterator it = srcDirs.iterator()
    while (it.hasNext()) {
        FileCollection fc = it.next()
        for (File f : fc.files) {
            if (f.exists()) {
                System.out.println(f.absolutePath)
            } else {
                it.remove()
                System.out.println("\tremoving: " + f.absolutePath)
            }
        }
    }
    return files(srcDirs)
}

// get source dirs for project dependencies
FileCollection getJacocoSrcDirs() {
    Set srcDirs = subprojects.sourceSets.main.allSource.srcDirs
    return files(srcDirs)
}

task jacocoMerge(type: JacocoMerge) {
    executionData = getJacocoExecFiles()
    destinationFile = project.file("$buildDir/jacoco/data/jacoco.exec")
}
// generate coverage report for this project and all its project dependencies
task jacocoMergedReport(type: JacocoReport) {
    dependsOn jacocoMerge
    System.out.println("merged execs: " + jacocoMerge.destinationFile);
    reports {
        xml.enabled false
        csv.enabled false
        html.destination "$buildDir/reports/jacoco"
    }

    classDirectories = files(getJacocoClassDirs().collect {
        fileTree(dir: it, exclude: ['com/**/gradle/**'])
    })
    sourceDirectories = getJacocoSrcDirs()

    executionData jacocoMerge.destinationFile
}

task testReport(type: TestReport) {
    destinationDir = file("$buildDir/reports/allTests")
    // Include the results from the `test` task in all subprojects
    reportOn subprojects*.test
}
